#!/usr/bin/python
# -*- encoding: utf-8 -*-

"""
opendkim-manage - DKIM managment tool for LDAP

Copyright (c) 2018 by R.N.S.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
"""

from __future__ import print_function

import argparse
import ConfigParser
import datetime
import hashlib
import inspect
import os
import random
import re
import string
import sys
import time
import traceback

from copy import copy
from operator import itemgetter
from pprint import pformat

import dns.query
import dns.resolver
import dns.tsigkeyring
import dns.update
import ldap
import ldap.modlist as modlist
import ldap.sasl
import ldapurl

from dns.tsig import HMAC_SHA256, HMAC_SHA384, HMAC_SHA512
from M2Crypto import RSA, BIO

try:
    from colorama import init, Fore, Style
    init()
    have_color = True
except ImportError:
    have_color = False


__author__ = "Christian Rößner"
__copyright__ = "Copyright (c) 2018 by R.N.S."
__credits__ = ["Andreas Schulze", "Patrick Ben Koetter"]
__license__ = "GPL"
__version__ = "0.1.3"
__maintainer__ = "Christian Rößner"
__email__ = "c@roessner.co"
__status__ = "Development"

NAME = "opendkim-manage"

DEBUG = True
VERBOSE = False
USE_COLOR = False
INTERACT = False


class GlobalCfg(object):
    """Global configuration options
    """
    delete_delay = 10
    expire_after = 365
    term_bg = "dark"


class CfgFile(object):
    """Config file parser

    :param cfgfile: Parse a configuration file
    """
    def __init__(self, cfgfile):
        self.__config = ConfigParser.ConfigParser()

        self.globals = dict()
        self.ldap = dict()
        self.dns = dict()

        # All known sections
        sections = (
            "global", "ldap", "dns"
        )

        # All known options
        global_opts = (
            "expire_after", "delete_delay", "selectorformat",
            "use_dkim_identity", "terminal_background"
        )
        ldap_opts = (
            "uri", "bindmethod", "saslmech", "filter", "domain",
            "use_starttls", "reqcert", "ciphers", "cert", "key", "ca",
            "authz_id", "binddn", "bindpw"
        )
        dns_opts = (
            "primary_nameserver", "tsig_key_file", "tsig_key_name",
            "algorithm", "ttl"
        )

        success = self.__config.read(cfgfile)
        if len(success) == 0:
            print(_c("Error: Config file '{0}' can not be read".format(
                cfgfile), "red"), file=sys.stderr)
            sys.exit(os.EX_OSERR)

        for sec in iter(self.__config.sections()):
            if sec not in sections:
                print(_c("Error: Unknown section '{0}'".format(sec), "red)"),
                      file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)

        if not self.__config.has_section("global"):
            print(_c("Error: Missing requried section 'global'", "red"),
                  file=sys.stderr)
            sys.exit(os.EX_SOFTWARE)
        if not self.__config.has_section("ldap"):
            print(_c("Error: Missing requried section 'ldap'", "red"),
                  file=sys.stderr)
            sys.exit(os.EX_SOFTWARE)

        # Parse global options
        for opt in iter(global_opts):
            self.globals[opt] = None
        s = "global"
        for opt in iter(self.__config.options("global")):
            if opt not in global_opts:
                print(_c("Error: Unknown option '{0}' in section "
                         "'global'".format(opt), "red"), file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)
            if opt in ("delete_delay", "expire_after"):
                try:
                    self.globals[opt] = self.__config.getint(s, opt)
                except ValueError:
                    pass
            elif opt == "use_dkim_identity":
                try:
                    self.globals[opt] = self.__config.getboolean(s, opt)
                except ValueError:
                    pass
            else:
                self.globals[opt] = self.__config.get(s, opt)

        # Parse LDAP options
        for opt in iter(ldap_opts):
            self.ldap[opt] = None
        s = "ldap"
        for opt in iter(self.__config.options("ldap")):
            if opt not in ldap_opts:
                print(_c("Error: Unknown option '{0}' in section 'ldap'".format(
                         opt), "red"), file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)
            if opt == "use_starttls":
                try:
                    self.ldap[opt] = self.__config.getboolean(s, opt)
                except ValueError:
                    self.ldap[opt] = False
            else:
                self.ldap[opt] = self.__config.get(s, opt)

        # Parse DNS options
        if "dns" in self.__config.sections():
            for opt in iter(dns_opts):
                self.dns[opt] = None
            s = "dns"
            for opt in iter(self.__config.options("dns")):
                if opt not in dns_opts:
                    print(_c("Error: Unknown option '{0}' in section "
                             "'dns'".format(opt), "red"), file=sys.stderr)
                    sys.exit(os.EX_SOFTWARE)
                if opt == "algorithm":
                    value = self.__config.get(s, opt)
                    if value == "hmac_sha256":
                        self.dns[opt] = HMAC_SHA256
                    elif value == "hmac_sha384":
                        self.dns[opt] = HMAC_SHA384
                    elif value == "hmac_sha512":
                        self.dns[opt] = HMAC_SHA512
                    else:
                        print(_c("Error: {0} unsupported HMAC: {1}".format(
                            opt, value), "red"), file=sys.stderr)
                        sys.exit(os.EX_SOFTWARE)
                    continue
                elif opt == "ttl":
                    try:
                        self.dns[opt] = self.__config.getint(s, opt)
                    except ValueError:
                        print(_c("Error: TTL in config file must be an "
                                 "integer: {0}".format(
                                    self.__config.get(s, opt)
                                 ), "red"), file=sys.stderr)
                        sys.exit(os.EX_SOFTWARE)
                    continue

                if opt == "tsig_key_file":
                    value = self.__config.get(s, opt)
                    if not os.path.exists(value):
                        print(_c("Error: Can not access TSIG key file "
                                 "'{0}'".format(value), "red"), file=sys.stderr)
                        sys.exit(os.EX_SOFTWARE)

                self.dns[opt] = self.__config.get(s, opt)


class Cmd(object):
    """Command line parser
    """
    def __init__(self):
        global INTERACT, DEBUG, VERBOSE, USE_COLOR

        parser = argparse.ArgumentParser(prog=NAME)

        parser.add_argument("--list", "-l",
                            default=False,
                            action="store_true",
                            help="List DKIM keys")
        parser.add_argument("--create", "-c",
                            default=False,
                            action="store_true",
                            help="Create a new DKIM key")
        parser.add_argument("--delete", "-d",
                            default=False,
                            action="store_true",
                            help="Delete one or many DKIM keys")
        parser.add_argument("--force-delete",
                            default=False,
                            action="store_true",
                            help="Force deletion of a DKIM key")
        parser.add_argument("--active",
                            default=False,
                            action="store_true",
                            help="Set DKIMActive to TRUE for a selector")
        parser.add_argument("--force-active",
                            default=False,
                            action="store_true",
                            help="Force activation of a DKIM key")

        parser.add_argument("--age", "-A",
                            default=None,
                            type=int,
                            help="The key has to be more(+) or less (-) then n "
                                 "days old")
        parser.add_argument("--domain", "-D",
                            default=None,
                            action="append",
                            type=str,
                            help="A DNS domain name")
        # Currently not reimplemented
        """
        parser.add_argument("--nosubdomain",
                            default=False,
                            action="store_true",
                            help="Don't match subdomains")
        """
        parser.add_argument("--selectorname", "-s",
                            default=None,
                            action="append",
                            type=str,
                            help="A selector name")
        parser.add_argument("--size", "-S",
                            default=2048,
                            type=int,
                            help="Size of DKIM keys (default: %(default)s)")
        parser.add_argument("--testkey", "-t",
                            default=False,
                            action="store_true",
                            help="Check that the listed DKIM keys are "
                                 "published and useable")

        parser.add_argument("--config", "-f",
                            default="/etc/opendkim-manage.cfg",
                            type=str,
                            help="Path to '{0}' config file. ".format(NAME) +
                                 "(default: '%(default)s'")
        parser.add_argument("--add-missing", "-m",
                            default=False,
                            action="store_true",
                            help="Add missing DKIM keys to LDAP objects")
        parser.add_argument("--max-initial",
                            default=0,
                            type=int,
                            help="Maximum number of newly created DKIM keys")
        parser.add_argument("--add-new", "-n",
                            default=False,
                            action="store_true",
                            help="Check age for DKIM keys and create new keys "
                                 "on demand")
        parser.add_argument("--rotate", "-r",
                            default=False,
                            action="store_true",
                            help="Rotate one or all DKIM keys")
        parser.add_argument("--auto", "-a",
                            default=False,
                            action="store_true",
                            help="Short for --add-missing, --add-new, --rotate "
                                 "and --delete")
        parser.add_argument("--expire-after", "-e",
                            default=None,
                            type=int,
                            help="Number of days after which new DKIM keys "
                                 "will be created with --add-new (default: "
                                 "{0} days)".format(
                                    GlobalCfg.expire_after))
        parser.add_argument("--delete-delay", "-y",
                            default=None,
                            type=int,
                            help="Delay deletion of old DKIM keys (default: "
                                 "{0} days)".format(
                                    GlobalCfg.delete_delay))
        parser.add_argument("--update-dns", "-u",
                            default=False,
                            action="store_true",
                            help="Update DNS zones")

        parser.add_argument("--interactive", "-i",
                            default=False,
                            action="store_true",
                            help="Turn on interactive mode")

        parser.add_argument("--debug",
                            default=False,
                            action="store_true",
                            help="Turn on debugging")
        parser.add_argument("--verbose", "-v",
                            default=False,
                            action="store_true",
                            help="Verbose output")
        parser.add_argument("--color",
                            default=False,
                            action="store_true",
                            help="Turn on colors for output")
        parser.add_argument("--version", "-V",
                            default=False,
                            action="store_true",
                            help="Print version and exit")

        self.config = parser.parse_args()

        # Some options require the '--domain' option being set
        if self.config.create:
            if not self.config.domain:
                print(_c("Error: Option '--domain' is required", "red"),
                      file=sys.stderr)
                sys.exit(os.EX_USAGE)

        # Some options require the '--selectorname' option being set
        if (self.config.delete or
            self.config.age or
            self.config.active) \
                and not self.config.selectorname:
            print(_c("Error: Option '--selectorname' is required", "red"),
                  file=sys.stderr)
            sys.exit(os.EX_USAGE)

        # Make sure, we do not use these command on a per-domain or
        # per-selector basis
        if (self.config.add_missing or self.config.add_new or
            self.config.rotate or self.config.auto) and \
                (self.config.domain or self.config.selectorname):
            print(_c("Error: Option '--domain' and/or '--selectorname' not "
                     "allowed", "red"), file=sys.stderr)
            sys.exit(os.EX_USAGE)

        if self.config.testkey and \
                self.config.domain and \
                self.config.selectorname:
            print(_c("Error: Only one of '--domain' or '--selectorname' "
                     "is required", "red"), file=sys.stderr)
            sys.exit(os.EX_USAGE)

        # Either --selectorname or --domain is required
        if self.config.testkey and not \
                (self.config.domain or self.config.selectorname):
            print(_c("Error: Option '--domain' or '--selectorname' is "
                     "required", "red"), file=sys.stderr)
            sys.exit(os.EX_USAGE)

        # Binary fields
        cmd_cleared = 0
        bit_mask = dict(m=1)

        # Bit shifter helper function
        def shift(x):
            x['m'] <<= 1
            return x['m']

        cmd_list = bit_mask['m']
        cmd_create = shift(bit_mask)
        cmd_delete = shift(bit_mask)
        cmd_rotate = shift(bit_mask)
        cmd_addmissing = shift(bit_mask)
        cmd_addnew = shift(bit_mask)
        cmd_auto = shift(bit_mask)

        # Only run one command at a time
        flags = cmd_cleared
        if self.config.list:
            flags |= cmd_list
        if self.config.create:
            flags |= cmd_create
        if self.config.delete:
            flags |= cmd_delete
        if self.config.rotate:
            flags |= cmd_rotate
        if self.config.add_missing:
            flags |= cmd_addmissing
        if self.config.add_new:
            flags |= cmd_addnew
        if self.config.auto:
            flags |= cmd_auto
        if flags != cmd_cleared:
            if flags != cmd_list and \
                    flags != cmd_create and \
                    flags != cmd_delete and \
                    flags != cmd_rotate and \
                    flags != cmd_addmissing and \
                    flags != cmd_addnew and \
                    flags != cmd_auto:
                print(_c("Error: Only one command at a time is allowed", "red"),
                      file=sys.stderr)
                sys.exit(os.EX_USAGE)

        DEBUG = self.config.debug
        VERBOSE = self.config.verbose
        USE_COLOR = self.config.color
        INTERACT = self.config.interactive


class LDAP(object):
    """LDAP connection class
    """
    def __init__(self, ldapcfg):
        """
        :param ldapcfg: Dictionary that contains LDAP settings
        :var self.__ldapcfg: Configuration data structure for LDAP
        :var self.__uriparts: Contains split LDAP uri parts
        :var self.__starttls: Flag that indicates TLS usage
        :var self.__sasl: Flag that indicates SASL usage
        :var self.__auth_token: If SASL is defined, store an auth token
        :var self.__con: LDAP connection handle
        :var self.configured: If the connection is initialized this flag is true
        :var self.__connected: If a LDAP connection exists this flag is true
        """
        self.__ldapcfg = ldapcfg
        self.__urlparts = None
        self.__sasl = False
        self.__auth_token = None
        self.__con = None

        self.configured = False
        self.connected = False

    def initialize(self):
        """Initialze an LDAP object
        """
        if not (self.__ldapcfg['uri'] and self.__ldapcfg['filter'] and
                self.__ldapcfg['domain']):
            print(_c("Error: One of 'uri', 'filter' or 'domain' is missing in "
                     "config file", "red"), file=sys.stderr)
        if not ldapurl.isLDAPUrl(self.__ldapcfg['uri']):
            print(_c("Error: Invalid LDAP URI specified", "red"))
            sys.exit(os.EX_SOFTWARE)
        self.__urlparts = ldapurl.LDAPUrl(self.__ldapcfg['uri'])

        if self.__ldapcfg['reqcert']:
            if self.__ldapcfg['reqcert'] == "never":
                reqcert = ldap.OPT_X_TLS_NEVER
                dbg("reqcert=NEVER")
            elif self.__ldapcfg['reqcert'] == "allow":
                reqcert = ldap.OPT_X_TLS_ALLOW
                dbg("reqcert=ALLOW")
            elif self.__ldapcfg['reqcert'] == "try":
                reqcert = ldap.OPT_X_TLS_TRY
                dbg("reqcert=TRY")
            elif self.__ldapcfg['reqcert'] == "demand":
                reqcert = ldap.OPT_X_TLS_DEMAND
                dbg("reqcert=DEMAND")
            else:
                print(_c("Error: Unsupport 'reqcert' argument", "red"),
                      file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)
            ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, reqcert)

        if self.__ldapcfg['ciphers']:
            ldap.set_option(
                ldap.OPT_X_TLS_CIPHER_SUITE, self.__ldapcfg['ciphers'])
            dbg("set ciphers")

        if self.__ldapcfg['cert']:
            if not os.path.exists(self.__ldapcfg['cert']):
                print(_c("Error: Can not read LDAP TLS cert file", "red"),
                      file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)
            ldap.set_option(
                ldap.OPT_X_TLS_CERTFILE, self.__ldapcfg['cert'])
            dbg("Set cert to {0}".format(self.__ldapcfg['cert']))
        if self.__ldapcfg['key']:
            if not os.path.exists(self.__ldapcfg['key']):
                print(_c("Error: Can not read LDAP TLS key file", "red"),
                      file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)
            ldap.set_option(
                ldap.OPT_X_TLS_KEYFILE, self.__ldapcfg['key'])
            dbg("Set key to {0}".format(self.__ldapcfg['key']))
        if self.__ldapcfg['ca']:
            if not os.path.exists(self.__ldapcfg['ca']):
                print(_c("Error: Can not read LDAP TLS CA file", "red"),
                      file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)
            ldap.set_option(
                ldap.OPT_X_TLS_CACERTFILE, self.__ldapcfg['ca'])
            dbg("Set ca to {0}".format(self.__ldapcfg['ca']))

        if self.__ldapcfg['bindmethod'] == "sasl":
            if self.__ldapcfg['saslmech']:
                if self.__ldapcfg['binddn'] and self.__ldapcfg['bindpw']:
                    if self.__ldapcfg['saslmech'].lower() == "digest-md5":
                        self.__auth_token = ldap.sasl.digest_md5(
                            self.__ldapcfg['binddn'],
                            self.__ldapcfg['bindpw']
                        )
                        dbg("SASL/DIGEST-MD5")
                    elif self.__ldapcfg['saslmech'].lower() == "cram-md5":
                        self.__auth_token = ldap.sasl.cram_md5(
                            self.__ldapcfg['binddn'],
                            self.__ldapcfg['bindpw']
                        )
                        dbg("SASL/CRAM-MD5")
                else:
                    if self.__ldapcfg['saslmech'].lower() == "external":
                        self.__auth_token = ldap.sasl.external(
                            self.__ldapcfg['authz_id'])
                        dbg("SASL/EXTERNAL")
                    elif self.__ldapcfg['saslmech'].lower() == "gssapi":
                        self.__auth_token = ldap.sasl.gssapi(
                            self.__ldapcfg['authz_id'])
                        dbg("SASL/GSSAPI")

                dbg("SASL enabled")
                self.__sasl = True

        self.configured = True

    def connect(self):
        """Connect to a LDAP server
        """
        con_string = "{0}://{1}".format(
            self.__urlparts.urlscheme, self.__urlparts.hostport)
        try:
            self.__con = ldap.initialize(con_string)
            dbg("connected to {0}".format(con_string))
            # Silently ignore starttls, if ldaps was given
            if self.__ldapcfg['use_starttls'] and \
                    self.__urlparts.urlscheme != "ldaps":
                self.__con.start_tls_s()
                dbg("STARTTLS")
            if self.__sasl:
                self.__con.sasl_interactive_bind_s("", self.__auth_token)
                dbg("SASL AUTH")
            else:
                if self.__ldapcfg['binddn'] and self.__ldapcfg['bindpw']:
                    self.__con.simple_bind_s(
                        self.__ldapcfg['binddn'], self.__ldapcfg['bindpw'])
                    dbg("Simple bind")
                else:
                    self.__con = None
                    return  # Treat this as being not connected!
        except Exception:
            print(_c("Error: Can not connect to LDAP server", "red"),
                  file=sys.stderr)
            sys.exit(os.EX_SOFTWARE)

        self.connected = True

    def search(self, domain=None, search_filter=None, base=None, attrs=None, search_scope=ldap.SCOPE_SUBTREE):
        """Common LDAP search

        :param domain: Searches the default filter for this domain
        :param search_filter: Custom search filter for LDAP
        :param base: Custom LDAP search base with sub scope
        :param attrs: List of custom LDAP result attributes
        :param search_scope: specifies how broad the search context is
        :return: Return a result list
        """
        if domain:
            assert isinstance(domain, str)
        if search_filter:
            assert isinstance(search_filter, str)
        if base:
            assert isinstance(base, str)

        assert isinstance(attrs, list)
        assert len(attrs) > 0

        if not self.configured:
            self.initialize()
        if self.configured:
            if not self.connected:
                self.connect()
            if self.connected and self.__con:
                if not search_filter:
                    if not domain:
                        domain = '*'
                    search_filter = self.__ldapcfg['filter'] % domain
                if not base:
                    base = self.__urlparts.dn
                dbg("filter={0}".format(search_filter))
                dbg("attrs={0}".format(attrs))
                rid = self.__con.search(base,
                                        search_scope,
                                        search_filter,
                                        attrs)
                raw_result = self.__con.result(rid, True, 60)
                dbg("raw_result={0}".format(pformat(raw_result)))
                if raw_result[0] is None:
                    self.__con.abandon(rid)
                    print(_c("WARN: LDAP search timed out", "cyan"))
                    return self._result()
                list_of_results = raw_result[1]
                return list_of_results
            else:
                return None

        return None

    def store_dkim_key(self, dn, pem_key, domain, identity=None):
        """Store a new RSA PEM formated key in LDAP

        :param dn: The DN for the newly created LDAP object
        :param pem_key: PEM formated RSA key
        :param domain: The domain name of the DKIM object
        :param identity: Optional string for DKIMidentity
        """
        if identity:
            assert isinstance(identity, str)

        attrs = dict()
        attrs['objectclass'] = ["top", "DKIM"]
        # attrs['DKIMSelector'] = selector
        attrs['DKIMKey'] = pem_key
        attrs['DKIMActive'] = "FALSE"
        attrs['DKIMDomain'] = domain
        if identity:
            attrs['DKIMIdentity'] = identity

        ldif = modlist.addModlist(attrs)
        dbg("ldif={0}".format(ldif))

        if not self.configured:
            self.initialize()
        if self.configured:
            if not self.connected:
                self.connect()
            if self.connected and self.__con:
                self.__con.add_s(dn, ldif)

    def delete_dkim_key(self, dn):
        """Delete a LDAP object

        :param dn: The DN of the LDAP object that is to be deleted
        """
        if not self.configured:
            self.initialize()
        if self.configured:
            if not self.connected:
                self.connect()
            if self.connected and self.__con:
                self.__con.delete_s(dn)

    def unset_active(self, dn):
        """Set current DKIM object inactive

        :param dn: DN of the LDAP object for which the attribute is deleted
        """
        if not self.configured:
            self.initialize()
        if self.configured:
            if not self.connected:
                self.connect()
            if self.connected and self.__con:
                try:
                    self.__con.modify_s(
                        dn, [(ldap.MOD_DELETE, "DKIMActive", "TRUE")])
                except Exception:
                    pass
                try:
                    self.__con.modify_s(
                        dn, [(ldap.MOD_ADD, "DKIMActive", "FALSE")])
                except Exception:
                    pass

    def set_active(self, dn):
        """Set current DKIM object active

        :param dn: DN of the LDPA object for which the attribute is added
        """
        if not self.configured:
            self.initialize()
        if self.configured:
            if not self.connected:
                self.connect()
            if self.connected and self.__con:
                try:
                    self.__con.modify_s(
                        dn, [(ldap.MOD_DELETE, "DKIMActive", "FALSE")])
                except Exception:
                    pass
                try:
                    self.__con.modify_s(
                        dn, [(ldap.MOD_ADD, "DKIMActive", "TRUE")])
                except Exception:
                    pass


class NoSelectornameError(Exception):
    """Exception that is raised, if a selector name does not exist
    """
    pass


class SelectorParseError(IndexError):
    """Exception that is raised, if the selector format can not be parsed
    """
    pass


class Selector(object):
    """Generate a selector from config file param 'selectorname'

    :param __pattern: Private class pattern that matches variables in the
    'selectorformat' string
    :param __prog: Regular expression compiled object
    :param name: Property fget function that returns the computed name for
    the 'selectorformat' string
    """
    def __init__(self, cfgarg):
        """
        :param cfgarg: Value for the 'selectorformat' string from config file
        :var self.__cfgarg: Stores the selector format string
        :var self.__name: Computed selector name
        """
        self.__cfgarg = cfgarg
        self.__name = None

    def get_name(self):
        """Property helper method

        :return: The computed selector name from the format string
        """
        if self.__name is None:
            raise NoSelectornameError()
        return self.__name

    def parse(self):
        """Parse the selector format and store the result in the 'name'
        attribute
        """
        self.__name = self.__prog.sub(self.__repl, self.__cfgarg)

    @staticmethod
    def __repl(matchobj):
        """Replaces format string pattern defined in 'selectorformat'

        :param matchobj: regular expression match object
        :return: Replacement for found groups
        """
        if matchobj.group(1):
            dbg("group(1): {0}".format(matchobj.group(1)))
            key = matchobj.group(1)
            length = 0

            if matchobj.group(2):
                dbg("group(2): {0}".format(matchobj.group(2)))
                length = int(matchobj.group(2)[1:])

            repl = ""
            if key.lower() == "randomhex":
                lst = [random.choice(
                    string.ascii_letters + string.digits) for _ in xrange(128)]
                rand = "".join(lst)

                if length == 0:
                    raise SelectorParseError()

                repl = hashlib.sha256(rand).hexdigest()[:length].upper()

            elif key.lower() == "year":
                repl = str(datetime.datetime.now().year)
            elif key.lower() == "month":
                repl = "{0:02d}".format(datetime.datetime.now().month)
            elif key.lower() == "day":
                repl = "{0:02d}".format(datetime.datetime.now().day)

            return repl
        else:
            return matchobj.group(0)

    # We allow random hex between 1 and 20 chars
    __pattern = r"\$\{(\w+)(:[0-9]+)?\}"
    __prog = re.compile(__pattern, flags=re.UNICODE | re.IGNORECASE)

    name = property(fget=get_name)


class InvalidSelectorname(Exception):
    """Exception that is raised, if the created selectorname is invalid
    """
    pass


class InvalidTSIGKeyFile(Exception):
    """Raise an exception, if the content of the TSIG key file is wrong
    """
    pass


class DNS(object):
    """Add and delete DNS records
    """
    def __init__(self, cf):
        """
        :param cf: config file object
        """
        self.__cf = cf
        self.__keyring = dns.tsigkeyring.from_text({
            self.__cf.dns['tsig_key_name']: self._get_key_from_file()
        })

    def add_dkim_key(self, zone, selectorname, rcontent):
        """Add a TXT record for a DKIM key

        :param zone: The domainname of the zone
        :param selectorname: The selector name
        :param rcontent: Text for the TXT record. The string must not be
        normalized for DNS, as this module does take care for it.
        """
        update = dns.update.Update(zone, keyring=self.__keyring,
                                   keyname=self.__cf.dns['tsig_key_name'],
                                   keyalgorithm=self.__cf.dns['algorithm'])
        rname = selectorname + "._domainkey"
        dbg(rname)
        rcontent = DNS._make255(rcontent)
        dbg(rcontent)
        update.add(rname, self.__cf.dns['ttl'], 'TXT', rcontent)
        response = dns.query.tcp(update, self.__cf.dns['primary_nameserver'])
        dbg(response)
        verbose(_c("'{0}.{1}.'".format(rname, zone), "yellow") + " TXT: '" +
                _c("{0}".format(rcontent), "blue") + "' created")

    def remove_dkim_key(self, zone, selectorname):
        """Remove a DKIM TXT record from DNS

        :param zone: The domainname of the zone
        :param selectorname: The selector name
        """
        update = dns.update.Update(zone, keyring=self.__keyring,
                                   keyname=self.__cf.dns['tsig_key_name'],
                                   keyalgorithm=self.__cf.dns['algorithm'])
        rname = selectorname + "._domainkey"
        dbg(rname)
        update.delete(rname)
        response = dns.query.tcp(update, self.__cf.dns['primary_nameserver'])
        dbg(response)
        verbose(_c("'{0}.{1}.'".format(rname, zone), "yellow") + " deleted")

    def _get_key_from_file(self):
        """Read a TSIG formatted key and extract the pure key
        """
        with open(self.__cf.dns['tsig_key_file']) as f:
            while True:
                line = f.readline()
                if line == "":
                    break
                if line.startswith("Key:"):
                    return line.split("Key:")[1].strip()
        raise InvalidTSIGKeyFile("TSIG key file format error")

    @staticmethod
    def _make255(arg):
        """A string must not be more than 255 bytes. Split the record in chunks

        :param arg: A TXT string that must be split into chunks
        :return: Normalized string suiteable for DNS updates
        """
        return " ".join(
            ['"' + arg[i:i+255] + '"' for i in range(0, len(arg), 255)])

    @staticmethod
    def calculated_rname(selector, domain):
        """Check, if the given record name conforms to DNS RFC1035
        """
        assert isinstance(selector, str)
        assert isinstance(domain, str)

        # The constructed rname
        record = selector + "._domainkey." + domain

        labels = record.split('.')
        count = 0
        # Count labels
        for label in iter(labels):
            if len(label) > 63:
                raise InvalidSelectorname(
                    "Label '{0}' too long: {1}>63".format(label, len(label)))
            count += len(label)

        # Count dots
        count += len(labels) - 1

        if count > 253:
            raise InvalidSelectorname("Record too long: {0}>253".format(count))

        return selector


class Manager(object):
    """Main class that handles all features of opendkim-manage
    """
    def __init__(self, cf, cmd):
        """
        :param cf: Config file object from a Cfg() call
        :param cmd: Command line object from a Cmd() call
        :var self.__cf: Stores the config file settings
        :var self.__cmd: Stores the command line parameters
        :var self.__ldap: Holds an LDAP object
        """
        self.__cf = cf
        self.__cmd = cmd
        self.__ldap = LDAP(cf.ldap)

    def cmd_list(self):
        """--list command

        Scan one or all domains and display the DKIMSelector attributes. If
        the object contains a DKIMActive attribute set to TRUE, mark the
        output as active.
        """

        cf = self.__cf
        cmd = self.__cmd
        lh = self.__ldap

        if cmd.config.list:
            verbose("Command list", "green")

        if cmd.config.domain and len(cmd.config.domain) > 0:
            # TODO: If we implement --nosubdomain, we need to modify this list
            domains = cmd.config.domain
        else:
            domains = ['*']

        for domain in iter(domains):
            # Get DN for a domain as a new search base
            list_of_results = lh.search(domain, attrs=[cf.ldap['domain']])
            for ldap_object in iter(list_of_results):
                dn = None
                domainname = None
                dkimselectors = list()

                error = False

                try:
                    dn = ldap_object[0]
                    domainname = ldap_object[1][cf.ldap['domain']][0]
                except KeyError:
                    error = True

                print("DNS domain '" + _c("{0}".format(domainname), "blue") +
                      "':")
                print("DN: " + _c("{0}".format(dn), "yellow"))

                if not error:
                    # Retrieve all DKIMSelectors
                    list_of_results2 = lh.search(
                        search_filter="(objectClass=DKIM)",
                        base=dn,
                        attrs=['DKIMSelector', 'DKIMActive', 'createTimestamp'],
			search_scope=ldap.SCOPE_ONELEVEL)
                    for ldap_object2 in iter(list_of_results2):
                        try:
                            dkimselectors = ldap_object2[1]['DKIMSelector']
                        except KeyError:
                            pass

                        if 'DKIMActive' in ldap_object2[1] and \
                                ldap_object2[1]['DKIMActive'][0] == "TRUE":
                            status = " (" + _c("active", "red") + ")"
                        else:
                            status = ""
                        ct_dt = self.convert_ldaptime_to_datetime(
                            ldap_object2[1]['createTimestamp'][0])

                        for dkimselector in iter(dkimselectors):
                            print("{0} DKIMSelector: ".format(
                                utc2local(ct_dt)) +
                                  _c("{0}".format(dkimselector), "magenta") +
                                  "{0}".format(status))

    # noinspection PyPropertyAccess
    def cmd_create(self, domainname=None):
        """--create command

        Either create a new LDAP object for DKIM manually, if a custom
        selector was specified or use the 'selectorformat' string to compute
        one on the fly.
        """
        if domainname:
            assert isinstance(domainname, str)

        cf = self.__cf
        cmd = self.__cmd
        lh = self.__ldap

        if cmd.config.create:
            verbose("Command create", "green")

        if cmd.config.selectorname and not domainname:
            if len(cmd.config.domain) > 1:
                print(_c("Error: Too many domains specified", "red"),
                      file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)
            if len(cmd.config.selectorname) > 1:
                print(_c("Error: Please specify only one 'selectorname'",
                         "red"), file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)
            try:
                selector = DNS.calculated_rname(
                    cmd.config.selectorname[0], cmd.config.domain[0])
            except InvalidSelectorname as rname_err:
                print(_c("Error: DNS rname error for selector '{0}': "
                         "{1}".format(cmd.config.selectorname[0], rname_err),
                         "red"), file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)

            # Get DN suffix for the new selector object
            list_of_results = lh.search(cmd.config.domain[0],
                                        attrs=[cf.ldap['domain']])
            if len(list_of_results) == 0:
                print(_c("Error: Domain '{0}' does not exist".format(
                    cmd.config.domain[0]), "red"), file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)
            ldap_object = list_of_results[0]
            dn = ldap_object[0]
            dbg("dn={0}".format(dn))

            # Make sure, we do not have an LDAP object already
            list_of_results = lh.search(
                search_filter="(&(objectClass=DKIM)(DKIMSelector={0}))".format(
                    selector), base=dn, attrs=['DKIMSelector'])
            if len(list_of_results) != 0:
                print(_c("Error: Object for selector '{0}' already "
                         "exists".format(selector), "red"), file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)

            # Generate RSA certificate
            priv_key, pub_key = self.generate_RSA_private_key(cmd.config.size)

            if INTERACT:
                print(priv_key)

            if self.ask("Do you want to save the DKIM key in LDAP?"):
                if cf.globals['use_dkim_identity']:
                    identity = "@" + cmd.config.domain[0]
                else:
                    identity = None

                dbg("Saving DKIM key to LDAP")
                lh.store_dkim_key(
                    "DKIMSelector={0},".format(selector) + dn, priv_key,
                    cmd.config.domain[0], identity)
                verbose("DN: " +
                        _c("{0}".format(
                            "DKIMSelector={0},".format(selector) + dn),
                            "yellow") +
                        " created")
                if cmd.config.update_dns:
                    ns = DNS(cf)
                    rcontent = "v=DKIM1; k=rsa; h=sha256; p=" + \
                               self.raw_cert(pub_key)
                    ns.add_dkim_key(cmd.config.domain[0], selector, rcontent)

        elif cf.globals['selectorformat']:
            if domainname:
                domains = [domainname]
            else:
                domains = cmd.config.domain

            for domain in iter(domains):
                dbg("domain={0}".format(domain))
                list_of_results = lh.search(domain, attrs=[cf.ldap['domain']])
                if len(list_of_results) == 0:
                    print(_c("Error: There do not exist any domains yet",
                             "red"))
                    sys.exit(os.EX_SOFTWARE)
                for ldap_object in iter(list_of_results):
                    error = False

                    dn = None
                    domainname = None

                    try:
                        dn = ldap_object[0]
                        domainname = ldap_object[1][cf.ldap['domain']][0]
                    except KeyError:
                        error = True

                    if not error:
                        # Generate RSA certificate
                        priv_key, pub_key = self.generate_RSA_private_key(
                            cmd.config.size)

                        if INTERACT:
                            print(priv_key)

                        if self.ask(
                                "Do you want to save the DKIM key in LDAP?"):
                            if cf.globals['use_dkim_identity']:
                                identity = "@" + domainname
                            else:
                                identity = None

                            sel = Selector(cf.globals['selectorformat'])
                            try:
                                sel.parse()
                            except SelectorParseError:
                                print(_c("Error: 'selectorformat' is "
                                         "invalid", "red"), file=sys.stderr)
                                sys.exit(os.EX_SOFTWARE)

                            dbg("sel.name={0}".format(sel.name))
                            try:
                                selector = DNS.calculated_rname(
                                    sel.name, domainname)
                            except InvalidSelectorname as rname_err:
                                print(_c(
                                    "Error: DNS rname error for selector "
                                    "'{0}': {1}".format(sel.name, rname_err),
                                    "red"), file=sys.stderr)
                                sys.exit(os.EX_SOFTWARE)

                            dbg("Saving DKIM key to LDAP")
                            lh.store_dkim_key(
                                "DKIMSelector={0},".format(selector) + dn,
                                priv_key,
                                domain,
                                identity)
                            verbose("DN: " +
                                    _c("{0}".format(
                                        "DKIMSelector={0},".format(
                                            selector) + dn),
                                        "yellow") +
                                    " created")
                            if cmd.config.update_dns:
                                try:
                                    ns = DNS(cf)
                                    rcontent = "v=DKIM1; k=rsa; h=sha256; " \
                                               "p=" + self.raw_cert(pub_key)
                                    ns.add_dkim_key(domain, selector, rcontent)
                                except Exception as ns_err:
                                    print(_c("WARN: DNS error: {0}".format(
                                        ns_err), "cyan"), file=sys.stderr)

        else:
            print(_c("WARN: No 'selectorformat' defined", "cyan"),
                  file=sys.stderr)

    def cmd_delete(self, selectorname=None):
        """--delete command

        Delete one or more DKIM objects from LDAP

        :param selectorname: Optional selector to delete
        """
        cmd = self.__cmd

        if cmd.config.delete:
            verbose("Command delete", "green")

        if selectorname:
            assert isinstance(selectorname, str)
            selectors = [selectorname]
        else:
            selectors = cmd.config.selectorname

        lh = self.__ldap

        for selector in iter(selectors):
            list_of_results = lh.search(
                search_filter="(&(objectClass=DKIM)(DKIMSelector={0}))".format(
                    selector),
                attrs=['DKIMSelector', 'DKIMDomain', 'DKIMActive',
                       'modifyTimestamp', 'createTimestamp'])
            if len(list_of_results) == 0:
                print(_c("WARN: Selector '{0}' does not exist".format(
                    selector), "cyan"), file=sys.stderr)
                continue

            ldap_object = list_of_results[0]

            dn = ldap_object[0]
            # Get the modifyTimestamp attribute. If an object was rotated,
            # its timestamp was changed. We compare this to delete-delay.

            # not with OpenLDAP, but modifyTimestamp may be unset
            # see https://tools.ietf.org/html/rfc2252#section-5.1.2
            # assuming, createTimestamp is always present
            if "modifyTimestamp" in ldap_object[1]:
                modify_timestamp = self.convert_ldaptime_to_datetime(
                    ldap_object[1]['modifyTimestamp'][0])
            else:
                modify_timestamp = self.convert_ldaptime_to_datetime(
                    ldap_object[1]['createTimestamp'][0])

            time_delta = datetime.timedelta(days=GlobalCfg.delete_delay)

            if not cmd.config.force_delete:
                if "DKIMActive" in ldap_object[1] and \
                        ldap_object[1]['DKIMActive'][0] == "TRUE":
                    print(_c("WARN: Can not remove active DKIM key from LDAP",
                             "cyan"), file=sys.stderr)
                    continue

            if modify_timestamp + time_delta < datetime.datetime.utcnow() or \
                    cmd.config.force_delete:
                if INTERACT:
                    print("DN: {0}".format(dn))

                if self.ask(
                        "Do you really want to delete the DKIM key from LDAP?"):
                    dbg("Delete DN: {0}".format(dn))
                    lh.delete_dkim_key(dn)
                    verbose("DN: " +
                            _c("{0}".format(dn), "yellow") +
                            _c(" deleted", "green"))
                    if cmd.config.update_dns:
                        try:
                            ns = DNS(self.__cf)
                            ns.remove_dkim_key(
                                ldap_object[1]['DKIMDomain'][0],
                                selector)
                        except Exception as ns_err:
                            print(_c("WARN: DNS error: {0}".format(ns_err),
                                     "cyan"), file=sys.stderr)
            else:
                verbose("DN: " +
                        _c("{0}".format(dn), "yellow") +
                        _c(" not deleted", "red"))

    def cmd_age(self, days=None, days_delta=None, selectorname=None):
        """--age command

        Compare the creation date of a DKM key with an amount of days.
        A positive value will check, if the DKIM key in LDAP is older, a
        negative value will check, if the DKIM key is older than a givven
        number of days.

        If no keyword was given, the amount of days is retrieved from the
        command line.

        :param days: The number of days for comparission
        :param days_delta: A datetime.timedelta object for comparission
        :param selectorname: A selectorname can either be given on command
        line or is set elsewhere in the code
        :return: Boolean. Depends on the days-sign.
        """
        if days:
            assert isinstance(days, int)
        if days_delta:
            assert isinstance(days_delta, datetime.timedelta)
        if selectorname:
            assert isinstance(selectorname, str)

        cmd = self.__cmd
        lh = self.__ldap

        if cmd.config.age:
            verbose("Command age", "green")

        if not selectorname:
            if len(cmd.config.selectorname) > 1:
                print(_c("Error: Please specify only one 'selectorname'",
                         "red"), file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)
            selectorname = cmd.config.selectorname[0]

        list_of_results = lh.search(
            search_filter="(&(objectClass=DKIM)(DKIMSelector={0}))".format(
                selectorname),
            attrs=['DKIMSelector', 'createTimestamp'])

        if len(list_of_results) == 0:
            print(_c("WARN: Selector '{0}' does not exist".format(
                selectorname), "cyan"), file=sys.stderr)
            sys.exit(os.EX_SOFTWARE)

        ldap_object = list_of_results[0]
        dn = ldap_object[0]
        create_timestamp = ldap_object[1]['createTimestamp'][0]

        dbg(""
            "dn={0}, create_timestamp={1}".format(dn, create_timestamp))

        ct = self.convert_ldaptime_to_datetime(create_timestamp)
        dbg("ct={0}".format(ct))

        if days:
            cmp_age = days
        else:
            cmp_age = cmd.config.age
        dbg("cmp_age={0}".format(cmp_age))

        # Older than or younger than logic flag
        negative = False
        if cmp_age < 0:
            negative = True

        if days_delta:
            dt = days_delta
            cmp_age = None
        else:
            if cmp_age < 0:
                cmp_age *= -1
            dt = datetime.timedelta(days=cmp_age)
        dbg("dt={0}".format(dt))

        cmp_date = datetime.datetime.utcnow() - dt

        # Check, if key is more than X days old
        if not negative or cmp_age is None:
            dbg("positive age")
            if cmp_date > ct:
                delta = cmp_date - ct
                dbg("DN: {0}: Key is older".format(dn))
                verbose("DN: " + _c("{0}".format(dn), "yellow") +
                        " ({0}): Key is older than {1} days, delta is"
                        " {2} days".format(
                            self.convert_ldaptime_to_datetime(
                                create_timestamp), dt.days, delta.days))
                return True
            else:
                delta = ct - cmp_date
                dbg("DN: {0}: Key is younger".format(dn))
                verbose("DN: " + _c("{0}".format(dn), "yellow") +
                        " ({0}): Key is younger than {1} days, delta is"
                        " {2} days".format(
                            self.convert_ldaptime_to_datetime(
                                create_timestamp), dt.days, delta.days))
                return False

        if negative:
            dbg("negative age")
            if cmp_date < ct:
                delta = ct - cmp_date
                dbg("DN: {0}: Key is younger".format(dn))
                verbose("DN: " + _c("{0}".format(dn), "yellow") +
                        " ({0}): Key is younger than {1} days, delta is"
                        " {2} days".format(
                            self.convert_ldaptime_to_datetime(
                                create_timestamp), dt.days, delta.days))
                return True
            else:
                delta = cmp_date - ct
                dbg("DN: {0}: Key is older".format(dn))
                verbose("DN: " + _c("{0}".format(dn), "yellow") +
                        " ({0}): Key is older than {1} days, delta is"
                        " {2} days".format(
                            self.convert_ldaptime_to_datetime(
                                create_timestamp), dt.days, delta.days))
                return False

    def cmd_active(self, selectorname=None):
        """--active command

        Set the DKIMActive attribute (TRUE) to a new selector. It scans all
        other LDAP objects from the same domain container object and set old
        DKIMActive attributes to FALSE.

        :param selectorname: The name of a selector for which the DKIMActive
        attribute is to be set TRUE
        """
        if selectorname:
            assert isinstance(selectorname, str)

        cmd = self.__cmd
        lh = self.__ldap

        if cmd.config.active:
            verbose("Command active", "green")

        if cmd.config.selectorname and len(cmd.config.selectorname) > 1:
            print(_c("Error: Please specify only one 'selectorname'", "red"),
                  file=sys.stderr)
            sys.exit(os.EX_SOFTWARE)

        if not selectorname:
            selectorname = cmd.config.selectorname[0]

        list_of_results = lh.search(
            search_filter="(&(objectClass=DKIM)(DKIMSelector={0}))".format(
                selectorname),
            attrs=['DKIMSelector'])
        if len(list_of_results) == 0:
            print(_c("Error: Specified DKIM selector does not exist", "red"),
                  file=sys.stderr)
            sys.exit(os.EX_SOFTWARE)

        result = self.cmd_testkey(selectorlist=[selectorname])
        dbg("Result cmd_testkey: {0}".format(result))
        if result[selectorname] or cmd.config.force_active:
            ldap_object = list_of_results[0]
            dn = ldap_object[0]

            # Try to find the parent container for the given selector
            pat = r"^DKIMSelector=[^,]+,(.+)"
            prog = re.compile(pat, flags=re.UNICODE | re.IGNORECASE)

            matchobj = prog.match(dn)
            if matchobj and matchobj.group(1):
                dbg("matchobj.group(1)={0}".format(
                    matchobj.group(1)))
                parent_dn = matchobj.group(1).lstrip()
            else:
                print(_c("Error: Can not determ the base URI for the given "
                         "selector", "red"), file=sys.stderr)
                sys.exit(os.EX_SOFTWARE)

            # Find old DKIM key, which currently has the DKIMActive attribute
            # set to TRUE
            list_of_results = lh.search(
                search_filter="(&(objectClass=DKIM)(DKIMActive=TRUE))",
                base=parent_dn,
                attrs=['DKIMActive'])

            # It MAY exist more than one DKIMActive(TRUE) object
            for ldap_object in iter(list_of_results):
                if INTERACT:
                    print("DN: {0}".format(ldap_object[0]))
                if self.ask(
                        "Do you really want to disable this DKIM key?"):
                    lh.unset_active(ldap_object[0])
                    verbose("DN: " +
                            _c("{0}".format(dn), "yellow") +
                            " now inactive")

            dbg("Found DNS record or --force-active used")
            if INTERACT:
                print("DN: {0}".format(dn))
            if self.ask("Do you want to enable this DKIM key?"):
                lh.set_active(dn)
                verbose("DN: " +
                        _c("{0}".format(dn), "yellow") +
                        " now active")

        else:
            # Only print warning, if --active was specified
            if cmd.config.active:
                print(_c("WARN: Not activating DKIM key. No DNS record "
                         "for selector '{0}'".format(selectorname),
                         "cyan"), file=sys.stderr)

    def cmd_testkey(self, selectorlist=None):
        """--testkey command

        Ask a DNS resolver for the public DKIM TXT record.

        :param selectorlist: An optional list of selector names, for which a
        query should be done. If not given, it uses '--selectorname'
        :return: A dictionary for each selector name. Values are true,
        if a record was found and false, if none was published in DNS.
        """
        if selectorlist:
            assert isinstance(selectorlist, list)

        cmd = self.__cmd
        lh = self.__ldap

        if cmd.config.testkey:
            verbose("Command testkey", "green")

        # Store success/fail status for each query
        result = dict()
        domains = dict()

        if not selectorlist:
            selectorlist = list()
            if cmd.config.domain:
                for domain in iter(cmd.config.domain):
                    list_of_results = lh.search(
                        search_filter="(&(objectClass=DKIM)"
                                      "(DKIMDomain={0}))".format(domain),
                        attrs=['DKIMSelector', 'DKIMDomain', 'DKIMKey'])
                    for ldap_object in iter(list_of_results):
                        selectorname = ldap_object[1]['DKIMSelector'][0]
                        domainname = ldap_object[1]['DKIMDomain'][0]
                        priv_key = ldap_object[1]['DKIMKey'][0]
                        selectorlist.append(selectorname)
                        domains[selectorname] = (domainname, priv_key)
            else:
                selectorlist = cmd.config.selectorname

        for selector in iter(selectorlist):
            result[selector] = False
            list_of_results = list()

            if len(domains) == 0:
                list_of_results = lh.search(
                    search_filter="(&(objectClass=DKIM)"
                                  "(DKIMSelector={0}))".format(selector),
                    attrs=['DKIMDomain', 'DKIMKey'])
            if len(list_of_results) > 0 or len(domains) > 0:
                if selector in domains:
                    domainname = domains[selector][0]
                    priv_key = domains[selector][1]
                else:
                    ldap_object = list_of_results[0]
                    domainname = ldap_object[1]['DKIMDomain'][0]
                    priv_key = ldap_object[1]['DKIMKey'][0]

                dns_query = "{0}._domainkey.{1}.".format(selector, domainname)

                dbg(dns_query)
                if cmd.config.testkey:
                    print("Query " + _c("{0}".format(dns_query), "yellow"))
                try:
                    answers = dns.resolver.query(dns_query, "TXT")
                    dbg(answers)
                    for rdata in answers:
                        if not result[selector]:
                            crt_begin = "-----BEGIN PUBLIC KEY-----\n"
                            crt_end = "-----END PUBLIC KEY-----\n"
                            crt = "".join(rdata.strings)
                            crt = crt[crt.find('p=')+2:]
                            # Reconstruct public certificate
                            crt = (crt_begin +
                                   "\n".join(
                                       [crt[i:i+64] for i in range(
                                           0, len(crt), 64)]) +
                                   '\n' +
                                   crt_end)
                            # Create a new public cert from the RSA private key
                            # and compare it with the public cert from DNS
                            memory = BIO.MemoryBuffer()
                            new_key = RSA.load_key_string(priv_key)
                            new_key.save_pub_key_bio(memory)
                            if crt == memory.getvalue():
                                verbose("DNS record OK")
                                result[selector] = True
                            else:
                                verbose("DNS record does not belong to "
                                        "private RSA key from LDAP")
                        if cmd.config.testkey:
                            print("TXT: {0}".format("".join(rdata.strings)))
                except dns.resolver.NXDOMAIN:
                    print(_c("TXT: not present (yet?):", "cyan"),
                          _c(dns_query, "blue"))
                except dns.resolver.NoAnswer:
                    print(_c("WARN: No answer from DNS server for: {0}".format(
                             dns_query), "red"))
                except dns.resolver.NoNameservers:
                    print(_c("WARN: No nameservers could be reached", "cyan"))
                except dns.resolver.TimeOut:
                    print(_c("WARN: DNS timeout happened", "cyan"))

            else:
                print(_c("WARN: DKIMSelector '{0}' does not exist".format(
                    selector), "cyan"))

        return result

    def cmd_rotate(self):
        """--rotate command

        Scan Some or all domains in LDAP for valid DKIM keys that should be
        switched to active state. It checks for the age of the DKIM objects
        as well as it does a DNS check, before swithing a DKIM key. If more
        than one possible DKIM object was found in LDAP, it iterates from the
        newest to the oldest, until it can successfully complete the task.
        """
        cf = self.__cf
        cmd = self.__cmd
        lh = self.__ldap

        if cmd.config.rotate:
            verbose("Command rotate", "green")

        if cmd.config.domain:
            domains = cmd.config.domain
        else:
            domains = '*'

        # Iterate through domain objects
        for domain in iter(domains):
            list_of_results = lh.search(domain, attrs=[cf.ldap['domain']])
            for ldap_object in iter(list_of_results):
                dn = ldap_object[0]
                try:
                    domainname = ldap_object[1][cf.ldap['domain']][0]
                except ValueError:
                    print(_c("WARN: Domain attribute '{0}' not present in "
                             "object {1}".format(cf.ldap['domain'], dn),
                             "cyan"), file=sys.stderr)
                    continue
                dbg("domain '{0}'".format(domainname))

                # Get full list of selector objects per domain
                list_of_results2 = lh.search(
                    search_filter="(&(objectClass=DKIM)(DKIMSelector=*))",
                    base=dn,
                    attrs=['DKIMSelector', 'DKIMActive', 'createTimestamp'])
                dts = list()
                active_dt = None
                for ldap_object2 in iter(list_of_results2):
                    dn_sel = ldap_object2[0]
                    selectorname = ldap_object2[1]['DKIMSelector'][0]
                    dbg("DN={0}".format(dn_sel))

                    if "DKIMActive" in ldap_object2[1] and \
                            ldap_object2[1]['DKIMActive'][0] == "TRUE":
                        dbg("Found DKIMActive TRUE")
                        active_dt = self.convert_ldaptime_to_datetime(
                            ldap_object2[1]['createTimestamp'][0])
                        continue
                    create_timestamp = ldap_object2[1]['createTimestamp'][0]

                    dbg("dn={0}, create_timestamp={1}".format(
                         dn_sel, create_timestamp))

                    dts.append((
                        dn,
                        selectorname,
                        self.convert_ldaptime_to_datetime(create_timestamp)
                    ))

                dts = sorted(dts, key=itemgetter(2), reverse=True)
                dbg("dts={0}".format(dts))

                if active_dt:
                    for i, selectorname in enumerate([x[1] for x in iter(dts)]):
                        dbg("Checking selector '{0}'".format(
                            selectorname))
                        # Check if the current key is newer than the active key
                        dbg("Checking dts[{0}][2]: {1} > {2}".format(
                            i, dts[i][2], active_dt))
                        if dts[i][2] > active_dt:
                            dbg("is greater!")
                            self.cmd_active(selectorname=dts[i][1])
                            break
                        else:
                            dbg("Selector '{0}' is younger than "
                                "the active selector".format(selectorname))
                else:
                    verbose("No active keys found for domain '" +
                            _c("{0}".format(domainname), "blue") + "'")

    def cmd_add_new(self):
        """--add-new command

        If the remaining lifetime for a DKIM key has reached, create a new
        key for each domain in LDAP
        """
        cf = self.__cf
        lh = self.__ldap

        if self.__cmd.config.add_new:
            verbose("Command add-new", "green")

        # Iterate through all domains
        list_of_results = lh.search(attrs=[cf.ldap['domain']])
        for ldap_object in iter(list_of_results):
            valid_key = False
            dn = ldap_object[0]
            try:
                domainname = ldap_object[1][cf.ldap['domain']][0]
            except ValueError:
                print(_c("WARN: Domain attribute '{0}' not present in "
                         "object {1}".format(cf.ldap['domain'], dn), "cyan"),
                      file=sys.stderr)
                continue
            dbg("domain '{0}'".format(domainname))

            # Get full list of selector objects per domain
            list_of_results2 = lh.search(
                search_filter="(&(objectClass=DKIM)(DKIMSelector=*))",
                base=dn,
                attrs=['DKIMSelector', 'DKIMActive', 'createTimestamp'])
            dts = list()
            active_dt = None
            active_selectorname = None
            for ldap_object2 in iter(list_of_results2):
                dn_sel = ldap_object2[0]
                selectorname = ldap_object2[1]['DKIMSelector'][0]
                dbg("DN={0}".format(dn_sel))

                if "DKIMActive" in ldap_object2[1] and \
                        ldap_object2[1]['DKIMActive'][0] == "TRUE":
                    dbg("Found active DKIM key")
                    if not self._expire_after(selectorname=selectorname):
                        dbg("Key is still fine")
                        valid_key = True
                        break
                    active_dt = self.convert_ldaptime_to_datetime(
                        ldap_object2[1]['createTimestamp'][0])
                    active_selectorname = selectorname
                    continue
                create_timestamp = ldap_object2[1]['createTimestamp'][0]

                dbg("dn={0}, create_timestamp={1}".format(
                     dn_sel, create_timestamp))

                dts.append((
                    selectorname,
                    self.convert_ldaptime_to_datetime(create_timestamp)
                ))

            if valid_key:
                continue

            dts = sorted(dts, key=itemgetter(1), reverse=True)
            dbg("dts={0}".format(dts))

            for selectorname, dt in iter(dts):
                # Do not create a new key, if all old keys are younger than
                # the current active one
                if active_dt and not dt < active_dt:
                    dbg("dt={0} active_dt={1}".format(
                        dt, active_dt))
                    if self._expire_after(selectorname=selectorname):
                        dbg("Too old. Need new key")
                        self.cmd_create(domainname=domainname)
                break
            else:
                # No other keys than the active key is present
                dbg("Empty dts. active_selectorname={0}".format(
                    active_selectorname))
                if not active_selectorname:
                    dbg("No active key found")
                    return
                if self._expire_after(selectorname=active_selectorname):
                    dbg("Too old. Need new key")
                    self.cmd_create(domainname=domainname)

    def cmd_add_missing(self):
        """--add-missing command

        Check the LDAP tree for domain containers and if a container does not
        have any DKIM keys yet, create a new DKIM object
        """
        cf = self.__cf
        cmd = self.__cmd
        lh = self.__ldap

        if self.__cmd.config.add_missing:
            verbose("Command add-missing", "green")

        if cmd.config.max_initial > 0:
            count_initial = True
        else:
            count_initial = False

        # Iterate through all domains
        list_of_results = lh.search(attrs=[cf.ldap['domain']])
        counter = 0
        for ldap_object in iter(list_of_results):
            if count_initial and counter == cmd.config.max_initial:
                dbg("Maximum initial reached ({0})".format(counter))
                return
            dn = ldap_object[0]
            try:
                domainname = ldap_object[1][cf.ldap['domain']][0]
            except ValueError:
                print(_c("WARN: Domain attribute '{0}' not present in "
                         "object {1}".format(cf.ldap['domain'], dn), "cyan"),
                      file=sys.stderr)
                continue
            dbg("domain '{0}'".format(domainname))

            # Get full list of selector objects per domain
            list_of_results2 = lh.search(
                search_filter="(&(objectClass=DKIM)(DKIMSelector=*))",
                base=dn,
                attrs=['DKIMSelector'])
            if len(list_of_results2) == 0:
                dbg("Need DKIM object")
                self.cmd_create(domainname=domainname)
                counter += 1

    def cmd_auto(self):
        """--auto command

        A shortcut for --add-missing, --add-new, --rotate and --delete. For
        the latter command, we only remove keys, if the date of keys are
        older than the active date (The object that has the DKIMDActive
        attribute set to TRUE)
        """
        cf = self.__cf
        lh = self.__ldap

        if self.__cmd.config.auto:
            verbose("Command auto", "green")

        verbose("Running --add-new")
        self.cmd_add_new()
        verbose("Running --add-missing")
        self.cmd_add_missing()
        verbose("Running --rotate")
        self.cmd_rotate()

        # Iterate through all domains
        list_of_results = lh.search(attrs=[cf.ldap['domain']])
        for ldap_object in iter(list_of_results):
            dn = ldap_object[0]
            try:
                domainname = ldap_object[1][cf.ldap['domain']][0]
            except ValueError:
                print(_c("WARN: Domain attribute '{0}' not present in "
                         "object {1}".format(cf.ldap['domain'], dn), "cyan"),
                      file=sys.stderr)
                continue
            dbg("domain '{0}'".format(domainname))

            # Get full list of selector objects per domain
            list_of_results2 = lh.search(
                search_filter="(&(objectClass=DKIM)(DKIMSelector=*))",
                base=dn,
                attrs=['DKIMSelector', 'DKIMActive', 'createTimestamp'])
            dts = list()
            active_dt = None
            for ldap_object2 in iter(list_of_results2):
                dn_sel = ldap_object2[0]
                selectorname = ldap_object2[1]['DKIMSelector'][0]
                dbg("DN={0}".format(dn_sel))

                if "DKIMActive" in ldap_object2[1] and \
                        ldap_object2[1]['DKIMActive'][0] == "TRUE":
                    dbg("Found active DKIM key")
                    active_dt = self.convert_ldaptime_to_datetime(
                        ldap_object2[1]['createTimestamp'][0])
                    continue
                create_timestamp = ldap_object2[1]['createTimestamp'][0]
                dts.append((
                    selectorname,
                    self.convert_ldaptime_to_datetime(create_timestamp)
                ))
                dbg("Added {0} to dts".format(selectorname))

            if active_dt:
                dbg("Checking for old keys")
                for selectorname, dt in iter(dts):
                    dbg("selectorname={0} dt={1} active_dt={2}".format(
                        selectorname, dt, active_dt))
                    if dt < active_dt:
                        dbg("Selector {0} is older than "
                            "active key".format(selectorname))
                        verbose("Running --delete for '" +
                                _c("{0}".format(selectorname), "magenta") + "'")
                        self.cmd_delete(selectorname=selectorname)
            else:
                dbg("No active keys found")
                # If no selector is currently active, we activate the newest
                if len(dts) > 0:
                    dts = sorted(dts, key=itemgetter(1), reverse=True)
                    dbg("dts={0}".format(dts))
                    verbose("Running --active for '" +
                            _c("{0}".format(dts[0][0]), "magenta") + "'")
                    self.cmd_active(selectorname=dts[0][0])

    def _expire_after(self, selectorname=None):
        """If the remaining days for a DKIM keys are below 'days'left',
        indicate that a new DKIM key should be created

        :param selectorname: The name of a selector
        :return: Boolean. True, if a new key should be created and false, if not
        """
        dbg("Running helper, selectorname={0}".format(selectorname))

        if selectorname:
            assert isinstance(selectorname, str)

        dl = GlobalCfg.expire_after

        if not selectorname:
            return False

        if self.cmd_age(days=dl, selectorname=selectorname):
            dbg("Key expired")
            return True

        return False

    # noinspection PyPep8Naming,PyTypeChecker
    @staticmethod
    def generate_RSA_private_key(bits):
        """Derived from the examples on Github
        https://gist.github.com/lkdocs/6519387

        Generate an RSA keypair with an exponent of 65537 in PEM format

        param bits: bits The key length in bits
        :return: Private key in PEM format
        """

        # noinspection PyUnusedLocal
        def keygen_callback(p, n, out):
            pass

        verbose("Generating RSA key with {0} bits".format(bits))
        new_key = RSA.gen_key(bits, 65537, callback=keygen_callback)
        memory = BIO.MemoryBuffer()
        new_key.save_key_bio(memory, cipher=None)
        private_key = memory.getvalue()
        new_key.save_pub_key_bio(memory)

        return private_key, memory.getvalue()

    @staticmethod
    def raw_cert(cert):
        """Remove -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY-----

        :param cert: PEM formatted certificate
        :return: Comment stripped certificate
        """
        return "".join(cert.split('\n')[1:-2])

    @staticmethod
    def ask(what):
        """Helper function for the interactive mode

        :return: Boolean. Tru if a question was answered positive, else false
        """
        if INTERACT:
            print(what + " (y/N): ", end="")
            while True:
                answer = raw_input("> ")
                if answer.lower() == "y":
                    return True
                if answer.lower() in ("", "n"):
                    return False
                print("Unknown answer. Please answer 'y' or 'n': ", end="")
        else:
            return True

    @staticmethod
    def convert_ldaptime_to_datetime(ldaptime):
        """Convert a LDAP timestamp to a datetime object

        :param ldaptime: CreateTimestamp or ModfiyTimestamp LDAP string
        :return: datetime object
        """
        assert isinstance(ldaptime, str)

        ct_year = int(ldaptime[:4])
        ct_month = int(ldaptime[4:6])
        ct_day = int(ldaptime[6:8])
        ct_hour = int(ldaptime[8:10])
        ct_min = int(ldaptime[10:12])
        ct_sec = int(ldaptime[12:14])

        # NOTE: RFC 4517 section 3.3.13
        # g-time-zone is 'Z' which is UTC
        return datetime.datetime(
            year=ct_year, month=ct_month, day=ct_day,
            hour=ct_hour, minute=ct_min, second=ct_sec)


def utc2local(utc):
    epoch = time.mktime(utc.timetuple())
    offset = datetime.datetime.fromtimestamp(epoch) - \
        datetime.datetime.utcfromtimestamp(epoch)

    return utc + offset


def _c(*args):
    if have_color and USE_COLOR:
        color = ""
        if GlobalCfg.term_bg == "dark":
            style = Style.BRIGHT
        else:
            style = Style.NORMAL

        if len(args) == 2:
            if args[1] == "red":
                color = Fore.RED
            elif args[1] == "blue":
                color = Fore.BLUE
            elif args[1] == "magenta":
                color = Fore.MAGENTA
            elif args[1] == "cyan":
                color = Fore.CYAN
            elif args[1] == "yellow":
                color = Fore.YELLOW
            elif args[1] == "green":
                color = Fore.GREEN

        return style + color + args[0] + Style.RESET_ALL
    else:
        return args[0]


def verbose(msg, *args):
    """Verbose ourput to terminal
    """
    if VERBOSE:
        print(_c(msg, *args))


def dbg(msg):
    """Helper function for the debug mode
    """
    stack = inspect.stack()
    try:
        the_class = stack[1][0].f_locals["self"].__class__
    except KeyError:
        the_class = "<unknown>"
    the_method = stack[1][0].f_code.co_name

    if DEBUG:
        style = ""

        if have_color and USE_COLOR:
            if GlobalCfg.term_bg == "dark":
                style = Style.BRIGHT
            else:
                style = Style.NORMAL
            _a1 = Fore.GREEN
            _a2 = Style.RESET_ALL
        else:
            _a1 = _a2 = ""
        print(style + _a1 + "DEBUG: [{0}/{1}]".format(
            the_class, the_method) + _a2 + " {0}".format(msg))


def main():
    """Main function
    """
    cmd = Cmd()

    if cmd.config.version:
        print("Version {0}".format(__version__))
        sys.exit(os.EX_OK)

    cf = CfgFile(cmd.config.config)

    if INTERACT:
        print("INFO: Interactive mode: ON")
    if DEBUG:
        print("INFO: Debugging turned: ON")

    # Set expire_after or its default
    if cf.globals['expire_after'] and not cmd.config.expire_after:
        GlobalCfg.expire_after = cf.globals['expire_after']
    if cmd.config.expire_after:
        GlobalCfg.expire_after = cmd.config.expire_after

    # Delete delay option
    if cf.globals['delete_delay'] and not cmd.config.delete_delay:
        GlobalCfg.delete_delay = cf.globals['delete_delay']
    if cmd.config.delete_delay:
        GlobalCfg.delete_delay = cmd.config.delete_delay

    if cf.globals['terminal_background'] in (None, "dark"):
        GlobalCfg.term_bg = "dark"
    else:
        GlobalCfg.term_bg = "light"

    if cmd.config.update_dns:
        for opt in ("primary_nameserver", "tsig_key_file", "tsig_key_name",
                    "algorithm", "ttl"):
            if opt not in cf.dns:
                print(_c("Error: Required option '{0}' not in config "
                         "file".format(opt), "red"), file=sys.stderr)
                sys.exit(os.EX_USAGE)

    # Do not print out passwords
    tmp = copy(cf.ldap)
    if "bindpw" in tmp:
        tmp["bindpw"] = "***** HIDDEN *****"
    dbg("cf.ldap: {0}".format(tmp))

    dbg("cf.dns: {0}".format(cf.dns))
    dbg("cf.globals: {0}".format(cf.globals))
    dbg("GlobalCfg.__dict__: {0}".format(GlobalCfg.__dict__))

    manager = Manager(cf, cmd)

    if cmd.config.list:
        manager.cmd_list()

    if cmd.config.create:
        manager.cmd_create()

    if cmd.config.delete:
        manager.cmd_delete()

    if cmd.config.age:
        if manager.cmd_age():
            sys.exit(0)
        else:
            sys.exit(1)

    if cmd.config.active:
        manager.cmd_active()

    if cmd.config.testkey:
        manager.cmd_testkey()

    if cmd.config.rotate:
        manager.cmd_rotate()

    if cmd.config.add_new:
        manager.cmd_add_new()

    if cmd.config.add_missing:
        manager.cmd_add_missing()

    if cmd.config.auto:
        manager.cmd_auto()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        if DEBUG:
            traceback.print_exc()
        print(_c("Error: Program unexpectedly terminated: {0}".format(e),
                 "red"), file=sys.stderr)
        sys.exit(os.EX_SOFTWARE)

    sys.exit(os.EX_OK)
